# Usbd
Implementation of a B+ Tree
Υλοποίηση Συστημάτων Βάσεων Δεδομένων
Εργασία 2
B+ Tree

Νέμανια Νέντιτς 1115201400124
Κωσταντίνος Στεφανίδης 1115201400192
Θανάσης Φιλιππίδης 1115201400215


Έχουν υλοποιηθεί όλα τα ερωτήματα. Η δομή που έχει ακολουθηθεί είναι η εξής.

File Metadata Block
 Κάθε B+ Tree file έχει ένα block με metadata στην αρχή του. Σε αυτό κρατάμε αρχικά ένα αναγνωριστικό string μήκους size of char * 15 το οποίο string είναι το “DIBLU$” ώστε κάθε φορα που ανοίγουμε ένα αρχείο να γνωρίζουμε εαν ειναι αρχείο B+ Tree, μετά υπάρχουν 6 int, ένας για τον τύπο του πρώτου attribute που είναι και το attribute κλειδί της βάσης μας, ένας για το μήκος αυτού του attribute, ένας για τον τύπο του δεύτερου attribute, ένας για το μήκος του δεύτερου, ένας που περιέχει το blockId της ρίζας του δέντρου και ένας για να ξέρουμε εαν η ρίζα είναι αρχικοποιημένη (εαν έχει μπει η πρώτη εγγραφη στο δέντρο πρακτικά) ή όχι.

B+ Tree Block Metadata
Από εκεί και πέρα η δομή όλων των υπόλοιπων blocks είναι ίδια και είναι η εξής: στο πρώτο byte κάθε block κρατάμε πληροφορία για το αν είναι block φύλλο οπότε αυτό το byte είναι 1 αλλιώς αν είναι block ευρετηρίου είναι 0, μετά κρατάμε έναν int με το blockId του συγκεκριμένου block, μετά κρατάμε έναν int ο οποίος είναι ο δείκτης στο δεξία block απο το block που βρισκόμαστε και παίρνει τιμές -2 αν βρισκόμαστε σε block ευρετηρίου, -1 αν βρισκόμαστε το τελευταίο κάτω δεξιά φύλλο και τιμές μεγαλύτερες του 0 (πρακτικά το id του δεξιού block) εαν είμαστε σε οποιοδήποτε άλλο block φύλλο και μετά κρατάμε έναν counter ο οποίος αναλόγως εαν είμαστε σε index block ή σε leaf block περιέχει τον αριθμό των κλειδιών ή των εγγραφών που υπάρχουν σε αυτό το block.

Leaf Block
Τα leaf blocks ακολουθούν την γενική δομή των b+ tree blocks ως προς το metadata τους. Αφού λοιπόν περάσουμε τα πρώτα metadata bytes του εκάστοτε block ξεκινάν οι εγγραφές. Η κάθε εγγραφή έχει μεγέθος len1 + len2 (όπου αυτά είναι τα μήκη του πρώτου και του δεύτερου attribute). Οι εγγραφές βρίσκονται η μία αμέσως μετά την άλλη χωρίς κάποια κενά bytes μεταξύ τους. Τα μόνα “κενά” bytes που μπορούν να υπάρξουν μέσα σε ένα block βρίσκονται στο τέλος του σε περίπτωση που τα ελεύθερα bytes για καταχώρηση εγγραφών δεν διαιρούνται ακριβώς από το μέγεθος της μίας εγγραφής.

Index Block
Και σε αυτά έχει ακολουθηθεί παρόμοια λογική με τα leaf blocks. Ακριβώς μετά τα metadata bytes έχουμε έναν int ο οποίος είναι ο δείκτης (blockPointer) (πρακτικά απλά το blockId) στο block που περιέχει κλειδιά μικρότερα του πρώτου κλειδιού του block στο οποίο βρισκόμαστε. Από εκεί και πέρα έχουμε ένα κλειδί και έναν blockPointer στα κλειδιά δεδομένα που αντιστοιχούν σε αυτό και μετα από αυτόν πάλι κλειδί και πάλι blockPointer counter (ο counter που αναφέρουμε στο B+ Tree Block) φορές συνολικά.

Other Structures
Εκτός από αυτά έχουμε κατασκευάσει τη δομή file_info και τον πίνακα openFiles ο οποίος σε κάθε κελί του έχει μια τέτοια δομή που κρατάει διάφορα χρήσιμα χαρακτηριστικά για το εκάστοτε ανοιχτό αρχείο. 

Scanning/Σαρωση
Οι ανοιχτες σαρωσεις αποθηκευονται στον πινακα openScans[MAX_SCANS].
	Οταν δημιουργειται μια σαρωση αρχικοποιειεται μια δομη struct Scan που περιμλαμβανει τα απαραιτηττα δεδομενα της. Η δομη αυτη αποθηκευεται στην πρωτη ελευθερη θεση του openScans[].
Τα δεδομενα που περιλαμβανει η δομη της σαρωσης ειναι:
fileDescriptor για να γνωριζει σε ποιο αρχειο απευθυνεται η σαρωση.
block_num & record_num για να γνωριζει σε ποιο μπλοκ βρικσεται η τελευταια εγγραφη που αναγνωστηκε. Οι τιμες αυτες οταν αρχικοποιειεται η σαρωση ειναι -1 αφου δεν εχει γινει καμια αναγνωση ακομα.
Op που περιλαμβανει τον τελεστη συγκρισης
value που περιλαμβανει δεικτη στην τιμη του πεδιου-κελιδιου προς συγκριση
ScanIsOver για να γνωριζει εαν η σαρωση εχει περατωσει. Δηλαδη οτι δεν υπαρχουν αλλες εγγραφες για να σαρωθουν.
return_value που ειναι δεικτης σε δυναμικη θεση μνημης. Αυτη η θεση μετα απο καθε αναγνωση κραταει την τιμη του πεδιου-δεδομενου που μολις διαβαστηκε απο τον δισκο.
Οταν καταστρεφεται μια σαρωση μαζι της καταστρεφεται και η θεση μνημης return_value και παραλληλα η θεση της στον πινακα openScans[] γινεται παλι NULL.
	FindNextEntry: η συναρτηση αυτη καλειται σε ανοιχτες σαρωσεις. Σε περιπτωση που αυτες οι σαρωσεις ειναι ακομα ενεργες, δεν εχουν περατωσει ακομα δηλαδη, προχωραει μεσω μιας switch(Scan→op) στην αντιστοιχη υποπεριπτωση. Καθε φορα που καλουμε μια σαρωση ελεγχουμε εαν ειναι η πρωτη φορα που καλειται για να δεσμευσουμε μνημη για το return_value και να εντοπισουμε ποια θα ειναι η πρωτη εγγραφη που θα διαβασουμε. Ολες τις αλλες φορες η FindNextEntry απλα διαβαζει την επομενη εγγραφη, ακομα και εαν αυτη βρισκεται στο διπλα μπλοκ, και αποφασιζει εαν θα συνεχισει κανονικα η θα πρεπει να περατωσει την σαρωση.
EQUAL: Την πρωτη φορα εντοπιζει το μπλοκ-φυλλο που θα επρεπε να βρισκεται η τιμη συγκρισης, αναζητα την ιδια μεσα στο μπλοκ, αν εντοπιστει την επιστρεφει, αν οχι τοτε τερματιζει την σαρωση. Ολες τις επομενες φορες απλα ελεγχει εαν υπαρχουν διπλοτυπα στο ιδιο μπλοκ, οταν τελειωσει και με αυτα περατωνει.
NOT_EQUAL: Την πρωτη φορα εντοπιζει το αριστεροτερο φυλλο, επειδη υπαρχει περιπτωση καποια φυλλα αριστερα να ειναι αδεια, εντοπιζει την αριστεροτερη εγγραφη και την επιστρεφει. Ολες τι επομενες φορες σαρωνει την επομενη εγγραφη μεχρι και την τελευταια και αποφασιζει εαν ικανοποιει την συνθηκη.
LESS_THAN & LESS_THAN_OR_EQUAL: Την πρωτη φορα εντοπιζει το αριστεροτεο φυλλο,, επειδη υπαρχει περιπτωση καποια φυλλα αριστερα να ειναι αδεια, εντοπιζει την αριστεροτερη εγγραφη και την επιστρεφει. Ολες τις επομενες φορες σαρωνει την επομενη εγγραφη μεχρι να εντοπισει μια εγγραφη που να μην ικανοποιει την συνθηκη.
GREATER_THN & GREATER_THAN_OR_EQUAL: Την πρωτη φορα εντοπιζει το μπλοκ-φυλλο που θα επρεπε να βρισκεται η τιμη συγκρισης, επειτα εντοπιζει την ιδια μεσα στο μπλοκ (ή την αμεσως μεγαλυτερη της εαν δεν υπαρχει). Ολες τις επομενες φορες σαρωνει την επομενη εγγραφη μεχρι να βρει την τελευταια, οποτε περατωνει και την σαρωση.
Η FindNextEntry εντοπιζει την επομενη εγγραφη με την βοηθεια της ScanNextRecord. Η συναρτηση αυτη ενημερωνει τον scan→record_num και εαν βγει εκτος οριων του μπλοκ-φυλλου τοτε ενημερωνει και το μπλοκ-φυλλο. Υπαρχει κατα την αλλαγη σε νεο μπλοκ να βρει οτι αυτο το μπλοκ δεν υπαρχει, που σημαινει οτι δεν εχουμε αλλες εγγραφες διαθεσημες για αναγνωση, τοτε επιστρεφει NO_NEXT_BLOCK και περατωνει η σαρωση.
